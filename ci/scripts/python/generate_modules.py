#!/usr/bin/env python3

from module_structure import module_including_source, items_with_access_modifiers_create
from module_operations import modules_load_from_file, modules_save_to_file
from example_structure import example_create
from example_operations import example_intersection_from_examples, example_union_from_examples, examples_load_from_file
from example_module_operations import example_filter_items_present_in_modules, module_convert_from_example, example_convert_from_module
import re
import argparse
import json
import copy
import sys

import pprint
pp = pprint.PrettyPrinter()


def generate_modules(examples, modules_builtin, modules_cmake):
    """Automaticly generate remaining modules from the list of examples and
       provided, builtin modules. Module generation is based on the sources.
       Module is assumed to be well defined when every source inside of it
       is present in every example. Sources in the module are always used
       together.

    Arguments:
        examples {Examples} -- List of examples from which we deduce modules
        modules_builtin {Modules} -- Dictionary of builtin modules. We assume that
        all modules defined inside of this dictionary are intrisic.
        modules_cmake {Modules} -- Dictionary of known modules verified by a
        developer.

    Returns:
        Modules -- Dictionary of modules which contains autogenerated, builtin 
        and cmake provided modules.
    """
    # This dict contains new modules
    modules = {}
    module_count = 0

    # All defined modules iterator
    def modules_iterator():
        for modules_dict in [modules_builtin, modules_cmake, modules]:
            for module in modules_dict.items():
                yield module

    # Collect sum example
    union_example = example_union_from_examples(examples)
    example_filter_items_present_in_modules(union_example, modules_iterator())

    # Iterate until all sources are processed
    while len(union_example["sources"]) > 0:
        # Pick first source at random
        union_source = next(iter(union_example["sources"]))

        #  Get common example for all examples which include union_source
        example = example_intersection_from_examples(
            examples,
            lambda e: not union_source in e["sources"])
        example_filter_items_present_in_modules(example, modules_iterator())

        # Check if every source in the above example is always paired together
        smaller_example_found = True
        while smaller_example_found:
            # Let's assume we didn't find smaller example...
            smaller_example_found = False

            # Iterate all example's sources.
            for example_source in example["sources"]:

                # Find other common example which always includes example_source
                other_example = example_intersection_from_examples(
                    examples, lambda e: not example_source in e["sources"])
                example_filter_items_present_in_modules(
                    other_example, modules_iterator())

                # Check if examples are minimal
                merged_example = example_intersection_from_examples(
                    [example, other_example])
                if len(merged_example["sources"]) != len(example["sources"]):
                    smaller_example_found = True
                    example = merged_example
                    break

        # Name module and add it to modules
        module = module_convert_from_example(example)
        module_count += 1
        modules["module" + str(module_count)] = module

        # Removed used sources from union_example
        example_filter_items_present_in_modules(union_example, [("", module)])

    # Validate all modules by checking that all sources, includes etc. are
    # covered by modules. These are only warning.
    union_example = example_union_from_examples(examples)
    examples_from_module = []

    for module in modules_iterator():
        example = example_convert_from_module(module[1])
        examples_from_module.append(example)

    union_example_from_modules = example_union_from_examples(
        examples_from_module)

    keys_to_validate = ["sources", "includes", "cflags", "asmflags", "ldflags"]
    for key in keys_to_validate:
        union_example[key].difference_update(union_example_from_modules[key])
        if len(union_example[key]) > 0:
            print("WARNING: " + key + " not handled:")
            pp.pprint(union_example[key])

    # Return all modules
    all_modules = {}
    for module in modules_iterator():
        all_modules[module[0]] = module[1]
    return all_modules


def generate_module_dependencies(examples, modules):
    """Function generates module's dependencies by looking at examples.  If for 
       all examples that use specific modules there are other source files, we 
       try to find dependency for them.

    Arguments:
        examples {Examples} -- List of examples
        modules {Modules} -- Dictionary of generated modules.
    """
    for module_name in modules:
        module = modules[module_name]

        # Get common example which includes all files from the modules
        def includes_all_sources_from_module(example):
            intersection = example["sources"].intersection(module["sources"])
            return len(intersection) != len(module["sources"])

        common_example = example_intersection_from_examples(
            examples, includes_all_sources_from_module)

        # Remove sources from common example
        common_example["sources"].difference_update(module["sources"])

        # While there are any sources left we try to find module for them.
        dependencies = items_with_access_modifiers_create()
        while len(common_example["sources"]) > 0:

            # Take one random source and find module for it.
            source = common_example["sources"].pop()
            found_module = module_including_source(source, modules)

            if found_module == None:
                print("WARNING: module not found for: " + source)
            else:
                dependencies["public"].add(found_module[0])
                common_example["sources"].difference_update(
                    found_module[1]["sources"])

        # Update module's dependencies:
        module["dependencies"] = dependencies


# Parse arguments
parser = argparse.ArgumentParser()
parser.add_argument("--all_examples")
parser.add_argument("--builtin_modules")
parser.add_argument("--cmake_modules")
parser.add_argument("--output")
args = parser.parse_args()

# List of all examples with sources, includes etc.
all_examples = examples_load_from_file(args.all_examples)

# Load builtin and cmake modules
builtin_modules = modules_load_from_file(args.builtin_modules)
cmake_modules = modules_load_from_file(args.cmake_modules)

# Generates modules
modules = generate_modules(all_examples, builtin_modules, cmake_modules)

# Generate dependencies
generate_module_dependencies(all_examples, modules)

# Convert modules to JSON and save to ouptut file
modules_save_to_file(args.output, modules)
