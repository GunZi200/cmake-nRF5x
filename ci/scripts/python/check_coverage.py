#!/usr/bin/env python3

import argparse
import re

from pathlib import Path
from nrf5_cmake.example import Example

from typing import Dict, List, Set
from nrf5_cmake.library import Library, LibraryProperty
from nrf5_cmake.library_description import LibraryVariant
from nrf5_cmake.library_operations import libraries_load_from_file
from nrf5_cmake.example_operations import examples_load_from_file, library_from_example

# Parse arguments
parser = argparse.ArgumentParser()
parser.add_argument("--generated_examples", required=True)
parser.add_argument("--generated_libraries", required=True)
parser.add_argument("--examples_dir", required=True)
parser.add_argument("--libraries_tests_dir", required=True)
args = parser.parse_args()

generated_examples: str = args.generated_examples
generated_libraries: str = args.generated_libraries
examples_dir: str = args.examples_dir
libraries_tests_dir: str = args.libraries_tests_dir

# Collect unique examples for each SDK.
examples: List[Example] = examples_load_from_file(generated_examples)
libraries = libraries_load_from_file(generated_libraries)


def get_relative_path(path: str) -> str:
    return str(Path(path).parent.parent.parent.parent)


def is_generated_library(name: str) -> bool:
    return re.match(r"lib[0-9]+", name) != None


unique_examples: Dict[str, Example] = {}
for example in examples:
    path = get_relative_path(example.local_path)
    unique_examples[path] = example

# Collect information about each example (how many sources are not covered yet)
remaining_example_libraries: Dict[str, Library] = {}

for (path, example) in unique_examples.items():
    example_library = library_from_example(example)
    for (library_name, library_desc) in libraries.items():
        if is_generated_library(library_name):
            continue
        library = library_desc.library_for_sdk_version(example.sdk_version)
        if library == None:
            continue
        example_library.difference_update(library)
    remaining_example_libraries[path] = example_library


sorted_examples_by_remaining_example_libraries = sorted(
    remaining_example_libraries.items(),
    key=lambda a: len(a[1].sources)
)

# Collect information about examples, which are already covered
covered_examples: Set[str] = set()
for path in Path(examples_dir).rglob('CMakeLists.txt'):
    path = str(path.parent).replace(examples_dir, "examples")
    covered_examples.add(path)

# Collect example statistics
total_number_of_examples = len(sorted_examples_by_remaining_example_libraries)

# Remove covered examples
remaining_examples = list(filter(
    lambda a: a[0] not in covered_examples,
    sorted_examples_by_remaining_example_libraries
))

remaining_number_of_examples = len(remaining_examples)
covered_number_of_examples = total_number_of_examples - remaining_number_of_examples

# Print information about examples
print("\n\n########################### EXAMPLES ###########################")
print("Total examples: " + str(total_number_of_examples))
print("Remaining examples: " + str(remaining_number_of_examples))
print("Covered examples: " + str(covered_number_of_examples))

max_examples = 20
print("Example candidates: (top " + str(max_examples) +
      " with least amount of sources)")
for (example_name, example_library) in remaining_examples:
    max_examples -= 1
    if max_examples == 0:
        break
    print(" * " + example_name)
    for source in example_library.sources:
        print("   - " + source)

# Libraries stats
total_libraries = len(libraries)
covered_libraries = 0
covered_libraries_obj = 0
autogenerated_libraries = 0
tested_libraries = 0
for path in Path(libraries_tests_dir).rglob('CMakeLists.txt'):
    tested_libraries += 1

remaining_libraries = []
for (library_name, library_desc) in libraries.items():
    if not is_generated_library(library_name):
        if library_desc.variant == LibraryVariant.OBJECT:
            covered_libraries_obj += 1
        covered_libraries += 1
        continue
    autogenerated_libraries += 1
    remaining_libraries.append((library_name, library_desc.library))


def count_auto_generated_libs(dependencies: Set[str]) -> int:
    count = 0
    for dependency in dependencies:
        if is_generated_library(dependency):
            count += 1
    return count


remaining_libraries.sort(
    key=lambda l: count_auto_generated_libs(
        l[1].get_prop(LibraryProperty.DEPENDENCIES).get_all_items()
    )
)

# Print information about libraries
print("\n\n########################## LIBRARIES ###########################")
print("Total libraries (estimated): " + str(total_libraries))
print("Remaining libraries (estimated): " + str(autogenerated_libraries))
print("Covered libraries: " + str(covered_libraries))
print("Covered libraries (obj only): " + str(covered_libraries_obj))
print("Tested libraries (obj only): " + str(tested_libraries))

max_libraires = 20
print("Library candidates: (top " + str(max_libraires) +
      " with least amount of remaining deps)")
for (library_name, library) in remaining_libraries:
    max_libraires -= 1
    if max_libraires == 0:
        break
    print(" * " + library_name)
    for source in library.sources:
        print("   - " + source)
